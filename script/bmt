#!/Users/brian/bin/perl
use v5.32;

use App::bmt;

package App::bmt;

use experimental qw(signatures);

use Antsy qw(:all);
use File::Basename;
use File::Spec::Functions;
use Module::CoreList;
use Mojo::Util qw(dumper trim);

my %Commands;

=head1 NAME

bmt - brian's module tool

=head1 SYNOPSIS

	% bmt COMMAND

=head1 DESCRIPTION

I use this to manage my work in Perl modules. It's very particular to
how I do things.

First, my F<Makefile.PL>'s are modulinos. They construct their argument
lists to C<WriteMakefile> but don't actually do anything unless it's
call as a program. Load it like a module and I can get that argument list
without the program doing its work. I can then inspect that data structure.

Second, the modulino uses the package name of the main module and return
that package name. As such, when I C<require './Makefile'>, I get back
a package name. I can use that to call methods in the modulino.

=cut

sub MODIFY_CODE_ATTRIBUTES ( $package, $code_ref, $attribute ) {
	my( $attribute_name ) = $attribute =~ m/\A(\w+)/;

	no strict 'refs';
	if( exists &{"_$attribute_name"} ) { return &{"_$attribute_name"}( @_ ) }
	else { die "Unknown attribute <$attribute_name>\n" }
	}

sub _register ( $package, $code_ref, $attribute ) {
	my $rc = require B;
	my( $sub_name )    = B::svref_2object( $code_ref )->GV->NAME;
	my( $description ) = $attribute =~ m/ \A register \( \s* " ([^"]+) " \s* \) /x;

	$Commands{ $sub_name } = [ $code_ref, $description ];

	return;
	}

my %Config;

run( @ARGV ) unless caller;

sub run ( @args ) {
	my( $command, @cmd_args ) = @args;
	$command //= 'help';

	my $config_file = catfile( $ENV{HOME}, '.bmt' );
	if( -e $config_file ) {
		state $rc = require Mojo::File;
		state $rc2 = require Mojo::JSON;
		%Config = Mojo::JSON::decode_json( Mojo::File->new( $config_file )->slurp )->%*;
		}

	if( exists $Commands{$command} ) {
		$Commands{$command}->[0]( @cmd_args );
		}
	else {
		say STDERR "Command <$command> wasn't found. See `$^O help`";
		}
	}

=head2 Commands

=cut


=item * actions

Open the GitHub actions page.

=cut

sub actions   :register("open the actions Github page") { _browser( github('actions') ) }

=item * all_remote

I like to have my repos stored on multiple services so I can tolerate
the failure of a couple of them. So far I use Github as the primary
and Bitbucket and Gitlab as the backups.

There's a curious thing you can do with a remote: it can take multiple
push urls. Use Github as the fetch URL, but push to all the services
through one remote. Since I don't mess with Bitbucket or Gitlab, those
should never be out of sync. And, it they are, I just delete the repo
and start again with a fresh push.

This bit of code took me awhile to simplify to the point where it
could work. The goal is to collect all the URLs I need to push to.

First, there has to be an origin. I'd like to fix that at some point,
but that's how it is now. That's Github.

Second, there might already be remotes for Bitbucket and Gitlab. If
there are, grab their URLs. If there aren't, make them. The trick is
to guess what the URLs should be since I have several owners on Github
(counting organizations) but only single personal accounts on the
other services.

Then, if there isn't a remote named 'all', make that with Github
address. Grab all those URLs from the other remotes and add those as
pushurls if all doesn't already have them.

=cut

sub all_remote :register("configure the all remote") ( @args ) {
	my $origin_url = _fetch_url( 'origin' );
	unless( $origin_url ) {
		say "No URL for origin. Aborting...";
		return;
		}

	my %hosts = (
		bitbucket => 'git@bitbucket.org',
		gitlab    => 'git@gitlab.com',
		);

	my %remotes = ( 'origin', $origin_url );
	my @remotes = qw( bitbucket gitlab );
	foreach my $remote ( @remotes ) {
		$remotes{$remote} = do {
			if( _remote_exists( $remote ) ) { _capture_command( "git config remote.$remote.url" ) }
			else {
				no strict 'refs';
				my $user = &{"_${remote}_user"}();
				my $url = $origin_url =~ s|git\@github.com:(?:\S+?)/(\S+?)\.git$|$hosts{$remote}:$user/$1.git|r;
				_run_git_command( 'remote', 'add', $remote, $url );
				$url
				}
			};
		}

	unless( _remote_exists( 'all' ) ) {
		_run_git_command( 'remote', 'add', 'all', $origin_url ),
		}

	# these already exist, so don't re-add them
	my %push_urls =
		map { chomp; $_ => 1 }
		_capture_command( "git config --get-all remote.all.pushurl" );

	foreach my $url ( grep { defined } values %remotes ) {
		next if exists $push_urls{$url};
		_git_set_push_url( 'all', $url );
		}

	_run_git_command( 'push', '-u', 'all', 'master' );
	}

=item * appveyor

Open the main Appveyor page for this repo.

=cut

sub appveyor  :register("open the Appveyor page")       { _browser( _appveyor_page() ) }

=item * bitbucket

Open the main Bitbucket page for this repo.

=cut

sub bitbucket :register("open the main Bitbucket page") { _browser( _bitbucket_page() ) }

=item * cpan_testers

Output the latest CPAN Testers results for this module.

=cut

sub cpan_testers :register("show Testers result for the latest version") ( $release = undef ) {
	$release //= _latest_release_version();
	my $dist_name = _dist_name();
	my $url = sprintf 'http://api.cpantesters.org/v3/summary/%s/%s', $dist_name, $release;

	my $data = _ua()->get( $url )->result->json;
	return unless ref $data eq ref [];
	my $results = _classify( 'grade', $data );
	sprintf '%s / %s / %s',
		text_green() . (sprintf '%3s', $results->{pass} // '-') . reset(),
		text_red()   . (sprintf '%3s', $results->{fail} // '-') . reset(),
		text_cyan()  . (sprintf '%3s', $results->{na}   // '-') . reset();
	}

=item * cpanv

Output the latest CPAN version and release date.

=cut

sub cpanv :register("show the lastest CPAN version") ( @args ) {
	my $module = _metacpan()->module( _main_module() );

	my $date    = $module->{data}{date};
	my $version = $module->{data}{version};

	say "CPAN: @{[_main_module()]} $version ---> $date";
	}

=item * create_bb

Create the Bitbucket repo. This does not push the repo.

=item * create_gh

Create the GitHub repo. This does not push the repo.

=item * create_gl

Create the Gitlab repo. This does not push the repo.

=cut

sub create_bb :register("create a BitBucket repo") { create_bitbucket() }
sub create_gh :register("create a GitHub repo")    { create_github() }
sub create_gl :register("create a GitLab repo")    { create_gitlab() }

sub create_bitbucket ( @args ) {
	my $ua = _ua();

	my( $owner, $repo_name ) = _github_owner_repo();

	my $user = _bitbucket_user();
	my $url = sprintf 'https://%s:%s@api.bitbucket.org/2.0/repositories/%s/%s',
		$user, _bitbucket_app_password(),
		$user, $repo_name;

	my $default_bitbucket_project = 'PROJ';

	my $tx = $ua->post(
		$url,
		{ 'Content-type' => 'application/json' },
		json => { project => { key => $default_bitbucket_project } }
		);

	say do {
		if( $tx->result->is_success ) { "Created Bitbucket repo <$user/$repo_name>" }
		else { "Could not create Bitbucket repo\n" . $tx->res->to_string }
		};
	}

sub create_github ( $name, $description = 'An undescribed module' ) {
	my $ghojo = _ghojo();

	my $name //= do {
		my $settings = eval {
			my $r = _settings()->{META_MERGE}{resources}{repository}{url};
			my( $project ) = m{(?:git\@github.com:|https?://github.com/)[^/]+/([^/]+)};
			} // {};
		$settings->{META_MERGE}{resources}
		};

	my $rc = $ghojo->create_repo( $name, $description );
	if( $rc->is_success ) {
		say "Created repo <$name>";
		}
	else {
		die "Counld not create repo <$name>: " . dumper($rc);
		}
	}

sub create_gitlab ( @args ) {
# https://docs.gitlab.com/ee/api/projects.html#create-project-for-user
	my $ua = _ua();

	my( $owner, $repo_name ) = _github_owner_repo();

	my $token = $ENV{BMT_GITLAB_TOKEN};
	my $tx = $ua->post(
		'https://gitlab.com/api/v4/projects',
		{
			'Content-type'  => 'application/json',
			'Authorization' => "Bearer $token",
		},
		json => { name => $repo_name, visibility => 'public' }
		);

	say do {
		if( $tx->result->is_success ) { "Created Gitlab repo <$repo_name>" }
		else { "Could not create Gitlab repo\n" . $tx->res->to_string }
		};
	}

=item * create_repos

Create the GitHub, BitBucket, and Gitlab repos.

=cut

sub create_repos :register("create GitHub, Bitbucket, and Gitlab in one go") {
	&create_github;
	&create_bitbucket;
	&create_gitlab;
	}

=item * deps

Output the dependency chain.

=cut

sub deps :register("show the dependency chain for this dist") {
	my @queue = ( [ 0, _dist_name()] );
	my $mcpan = _metacpan();

	my $Seen = {};

	while( my $next = shift @queue ) {
		my $suffix = exists $Seen->{ $next->[1] } ?  ' <already seen>' : '';
		say "\t" x $next->[0], $next->[1], $suffix;
		next if $suffix;
		$Seen->{ $next->[1] }++;

		unshift @queue,
			map  { [ $next->[0] + 1, $_ ] }
			grep { defined }
			map  { _module_to_dist( $_ ) }
			grep { ! Module::CoreList::is_core( $_ ) and $_ ne 'perl' }
			sort
			map  { $_->{module} }
			grep { $_->{relationship} eq 'requires' }
			grep { $_->{phase} eq 'runtime' }
			map  { $_->@* }
			eval { $mcpan->release( $next->[1] )->{data}{dependency} } // [];
		}

	say "Dependency count: " . keys $Seen->%*;
	my $string = join " ", sort keys $Seen->%*;
	$string =~ s/.{50,70}\K\s/\n/g;
	say $string;
	}

=item * dump_dist

Output as JSON the distribution information from MetaCPAN.

	$ bmt dump_dist | jq -r .download_url
	https://cpan.metacpan.org/authors/id/B/BD/BDFOY/Tie-Cycle-1.226.tar.gz

=cut

sub dump_dist :register("output JSON for the MetaCPAN distribution info") {
	state $rc = require Mojo::JSON;
	say Mojo::JSON::encode_json( _metacpan()->release( _dist_name() )->{data} );
	}

=item * dump_module

Output as JSON the module information from MetaCPAN.

	$ bmt dump_module | jq -r .version
	1.226

=cut

sub dump_module :register("output JSON for the MetaCPAN module info") {
	state $rc = require Mojo::JSON;
	say Mojo::JSON::encode_json( _metacpan()->module( _main_module() )->{data} )
	}

=item * gh_name

Output the GitHub repository name ("owner/repo")

	$ bmt gh_name
	briandfoy/tie-cycle

=cut

sub gh_name :register("show the full_name of the Github repo") ( @args ) {
	say join '/', _github_owner_repo();
	}

=item *

Open the GitHub main page for this repo.

=cut

sub github :register("open the main Github page") { _browser( github() ) }

=item * gitlab

Open the Gitlab main page for this repo.

=cut

sub gitlab :register("open the main Gitlab page") { _browser( gitlab() ) }

=item * help

Output a list of commands. This is the default command that bmt uses
when you do not specify a command.

=cut

sub help :register("show the help message") ( @args ) {
	my( $longest ) = sort { length $b <=> length $a } keys %Commands;
	my $length = length $longest;

	say join "\n", map {
		sprintf "%-${length}s     %s", $_, $Commands{$_}->[1]
		} sort keys %Commands;
	}

=item * issues

Open the GitHub issues page.

=cut

sub issues :register("open the Github issues page") { _browser( github( 'issues' ) ) }

=item * licenses

List the licenses for all dependencies.

=cut

sub licenses :register("list the licenses involved in dependencies") {
	my @queue = ( [ 0, _dist_name()] );
	my $mcpan = _metacpan();

	my $Seen = {};
	my $Licenses = {};

	while( my $next = shift @queue ) {
		my $licenses = _license_for($next->[1]);
		say "\t" x $next->[0], $next->[1], ' ', $licenses;
		$Licenses->{$_}++ for split /\s*,\s*/, $licenses;

		next if $Seen->{ $next->[1] }++;

		unshift @queue,
			map  { [ $next->[0] + 1, $_ ] }
			grep { defined }
			map  { _module_to_dist( $_ ) }
			grep { ! Module::CoreList::is_core( $_ ) and $_ ne 'perl' }
			sort
			map  { $_->{module} }
			grep { $_->{relationship} eq 'requires' }
			grep { $_->{phase} eq 'runtime' }
			map  { $_->@* }
			eval { $mcpan->release( $next->[1] )->{data}{dependency} } // [];
		}

	say "License count: " . keys $Licenses->%*;
	say "Licenses: ", join " ", sort keys $Licenses->%*;
	}

=item * metacpan

Open the MetaCPAN page.

=cut

sub metacpan :register("open the MetaCPAN page")      { _browser( _metacpan_page() ) }

=item * module

Output the name of the main module.

=cut

sub module :register("output the main module name") { say _main_module() }

=item * new_module MODULE_NAME DESCRIPTION REPO_NAME

Use L<Distritbution::Cooker> to start a new module repository.

=cut

sub new_module :register("make a new module directory") ( $module_name, $description, $repo_name ) {
	$description //= "Undescribed module $module_name";
	$repo_name   //= sprintf 'https://github.com/%s/%s', _github_user(), lc($module_name) =~ s/::/-/gr;

	state $rc = require Distribution::Cooker;
	Distribution::Cooker->run( $module_name, $description, $repo_name );
	}

=item * null

Do nothing.

=cut

sub null :register("do nothing") { 1 }

=item * open_all

Open the Github, Gitlab, Bitbucket, and Appveyor pages all at once.

=cut

sub open_all :register("open Github, Gitlab, and Bitbucket in one go") ( @args ) {
	_browser($_) for ( gitlab(), bitbucket(), github(), appveyor() );
	}

=item * perlv

Show the declared Perl versions in the Perl module files.

=cut

sub perlv :register("show the declared Perl versions in various files") ( @args ) {
	state $rc = require Module::Extract::DeclaredMinimumPerl;

	my $minv = _settings()->{MIN_PERL_VERSION};

	_make();

	chomp( my @files = `find blib -name '*.pm'` );

	my %files;
	my $extor = Module::Extract::DeclaredMinimumPerl->new;
	foreach my $file ( @files ) {
		$files{$file} = $extor->get_minimum_declared_perl( $file )
		}

	my $f_string = join "\n\t", map { "$files{$_} => $_" } sort keys %files;

	say <<~"HERE";
	Min version: $minv
	Files:\n\t$f_string
	HERE
	}

=item * releases

Show the recent release history.

=cut

sub releases :register("show the recent release history") ( @args ) {
	cpan_info();
	print "\n";

	my $releases = _releases();

	foreach my $release ( $releases->@* ) {
		state $count = 0;
		next unless ref $release;
		last if $count++ > 10;
		printf "%15s   %-10s  %s\n", _cpan_testers($release->[0]), $release->@*;
		}
	}

=item * show_setup

Show the bmt setup.

=cut

sub show_setup :register("show what bmt thinks things are" ) {
	printf <<~"HERE", _github_user(), _gitlab_user(), _bitbucket_user();
		Github user:    %s
		Gitlab user:    %s
		Bitbucket user: %s
		HERE

	}

=item * start NAME DESCRIPTION

Start a new module with NAME and DESCRIPTION. This is the same
sequence as:

	new_module

=cut

sub start ( $name, $description = 'An undescribed module' ) {
	# make new module directory
	new_module( $name, $description );

	# set up git

	# create github

	# push to github

	# create bitbucket, gitlab

	# set up all
	all_remote();

	# push to all

	}

=item * test

Run C<make test>.

=cut

sub test :register("run the tests") ( @args ) { _make("test") }

=item * update_bmt

Install the lastest versions of the modules that bmt uses.

=cut

sub update_bmt :register("update the modules this tool needs") () {
	my @modules = do {
		my @found;
		open my $fh, '<:utf8', __FILE__
			or die "Could not open " . __FILE__ . ": $!\n";
		while( <$fh> ) {
			next unless m/
				(?-x:require) \s+
				(?<module>
					[A-Z][A-Z0-9_]*
					(?: \:\:[A-Z][A-Z0-9_]* )*
				)
				/ix;
			push @found, $+{module};
			}
		@found;
		};
	say "Modules are <@modules>";

	state $rc = require App::Cpan;
	App::Cpan->run( @modules );
	}

=item * workflows

Show a summary of the most recent GitHub action workflows.

=cut

sub workflows :register("show the last set of workflows") ( @args ) {
	state %colors = (
		completed   => 'bg_green',
		queued      => 'bg_cyan',
		in_progress => 'bg_yellow',
		success     => 'bg_green',
		failure     => 'bg_red',
		default     => 'bg_cyan',
		);

	my $result = _ghojo()->list_workflow_runs( _github_owner_repo() );
	if( $result->is_error ) {
		say "Error fetching workflows";
		say $result->long_summary;
		return;
		}

	foreach my $item ( $result->values->to_array->@* ) {
		state $id = do {
			my $id = $item->head_commit->id;
			say "HEAD is $id";
			say "Message: " . $item->head_commit->message;
			$id;
			};
		last unless $id eq $item->head_commit->id;
		my( $name, $status, $conclusion ) =
			map( { $item->{$_} // '' } qw(name status conclusion) );

		my $ex = $status eq 'completed' ? $conclusion : $status;

		$ex = do { no strict 'refs'; &{ $colors{$ex || 'default'} } . $ex . reset() };

		printf "%-12s %-12s\n", $name, $ex;
		}
	}

=item * version

Show the bmt version.

=cut

sub version :register("show the bmt version") { say basename($0) . " version " . App::bmt->VERSION . " using Perl " . $^V }


=head2 Mostly internal functions

=over 4

=cut

sub _appveyor_page ( @args ) {
	sprintf "https://ci.appveyor.com/project/%s/%s", _github_owner_repo();
	}

sub _bitbucket_page ( @args ) {
	my $url = _fetch_url( 'bitbucket' );
	# git@bitbucket.org:briandfoy/mac-propertylist.git
	$url =~ s|git\@bitbucket.org:|https://www.bitbucket.org/|;
	$url;
	}

=item * _bitbucket_user

Return the Bitbucket account name. It searches for names in this order:

    * The C<BITBUCKET_USER> environment variable
    * The C<bitbucket_user> key in the config JSON object in F<~/.bmt>
    * Literally C<briandfoy>

=cut

sub _bitbucket_user { $ENV{BITBUCKET_USER} // _bitbucket_user_from_all() // $Config{bitbucket_user} // 'briandfoy' }

# remote.all.pushurl=git@bitbucket.org:briandfoy/distribution-cooker.git
sub _bitbucket_user_from_all {
	my( $line ) = _git_config_list( qr/^remote.all.pushurl=git\@bitbucket.org:/ );
	my( $user ) = $line =~ qr|git\@bitbucket.org:(.+?)/|;
	$user;
	}

=item * _bitbucket_app_password

Return the Bitbucket app password

=cut

sub _bitbucket_app_password { $ENV{BMT_BITBUCKET_APP_PASSWORD} }

=item * _browser( URL )

Open the URL in your browser

=cut

sub _browser ( $url ) {
	no strict 'refs';
	my $handler = "_open_$^O";
	die "No open handler for $^O" unless defined &{$handler};
	&{$handler};
	}

=item * _capture_command( STRING )

Run the string as a command and return the result.

=cut

sub _capture_command ( $command ) {
	die "This is not a git repo!\n" unless -e '.git';
	chomp( my $v = `$command` );
	$v;
	}

sub _classify ( $key, $data = [] ) {
	my $results = {};
	foreach my $item ( $data->@* ) {
		$results->{ $item->{$key} }++;
		}
	$results;
	}

=item * _dist_name

Return the dist name, which is the main module name with dashes instead
of doubled colons.  Module::Release is Module-Release. This is mostly
true across CPAN, although very few things had other names (L<libwww-perl>
for example).

=cut

sub _dist_name () { _main_module() =~ s/::/-/gr }

=item * _fetch_url( REMOTE_NAME )

Get the fetch URL for the Git remote

=cut

sub _fetch_url ( $remote_name ) {
	my $command = "git config remote.${remote_name}.url";
	chomp( my $git_url = _capture_command( $command ) );
	warn "No $remote_name remote!\n" unless $git_url;
	$git_url;
	}

=item * _ghojo

Return a L<Ghojo> object

=cut

sub _ghojo () {
	state $rc = require Ghojo;
	state $default_file = catfile( $ENV{HOME}, '.github', 'bmt.token' );
	state $ghojo = do {
		my %args = do {
			if( defined $ENV{BMT_GITHUB_TOKEN} ) {
				( token => $ENV{BMT_GITHUB_TOKEN} );
				}
			elsif( defined $ENV{BMT_GITHUB_TOKEN_FILE} and -e $ENV{BMT_GITHUB_TOKEN_FILE} ) {
				( token_file => $ENV{BMT_GITHUB_TOKEN_FILE} )
				}
			elsif( -e $default_file ) {
				( token_file => $default_file )
				}
			};
		my $ghojo = Ghojo->new( \%args );

		if( $ghojo->is_error ) {
			say $ghojo->long_summary;
			exit(10);
			}

		$ghojo;
		};

	$ghojo;
	}

=item * _git_set_push_url( REMOTE, URL )

Add the URL to REMOTE. This command has many pieces!

=cut

sub _git_set_push_url ( $remote, $url ) {
	_run_git_command( 'remote', 'set-url', '--add', '--push', $remote, $url );
	}

sub _git_config_list ( $pattern = qr/./ ) {
	my @matching =
		grep { /$pattern/ }
		split /\R/,
		_capture_command( 'git config --list' );
	}

=item * _github_owner_repo

Return the owner and repo name for this Github clone.

=cut

sub _github_owner_repo () {
	my $url = _fetch_url( 'all' );
	die "No URL! Stopping!\n" unless $url;
	my( $owner, $repo ) = $url =~ m|git\@github.com:(\S+?)/(\S+?)\.git|;
	}

sub _github_page ( $path = '',  @args ) {
	_settings()->{META_MERGE}{resources}{repository}{web} . "/$path";
	}

=item * _github_user

Return the GitHub account name. It searches for names in this order:

    * The C<GITHUB_USER> environment variable
    * The GitHub account from the repo URL in the C<all> remote in F<.git/config>
    * The C<github_user> key in the config JSON object in F<~/.bmt>
    * Literally C<briandfoy>

=cut

sub _github_user { $ENV{GITHUB_USER} // _github_user_from_all() // $Config{github_user} // 'briandfoy' }

# remote.all.pushurl=git@github.com:briandfoy/distribution-cooker.git
sub _github_user_from_all {
	my( $line ) = _git_config_list( qr/^remote.all.pushurl=git\@github.com:/ );
	my( $user ) = $line =~ qr|git\@github.com:(.+?)/|;
	$user;
	}

sub _gitlab_page ( @args ) {
	my $url = _fetch_url( 'gitlab' );
	# git@gitlab.com:briandfoy/mac-propertylist.git
	$url =~ s|git\@gitlab.com:|https://www.gitlab.com/|;
	$url;
	}

=item * _gitlab_user

Return the Gitlab account name. It searches for names in this order:

    * The C<GITLAB_USER> environment variable
    * The Gitlab account from the repo URL in the C<all> remote in F<.git/config>
    * The C<gitlab_user> key in the config JSON object in F<~/.bmt>
    * Literally C<briandfoy>

=cut

sub _gitlab_user { $ENV{GITLAB_USER} // _gitlab_user_from_all() // $Config{gitlab_user} // 'briandfoy' }

# remote.all.pushurl=git@gitlab.com:briandfoy/distribution-cooker.git
sub _gitlab_user_from_all {
	my( $line ) = _git_config_list( qr/^remote.all.pushurl=git\@gitlab.com:/ );
	my( $user ) = $line =~ qr|git\@gitlab.com:(.+?)/|;
	$user;
	}

=item * _latest_release_version

Return the latest release version

=cut

sub _latest_release_version { _releases()->[0][0] }

sub _license_for ( $dist ) {
	state $Seen;
	return $Seen->{$dist} if exists $Seen->{$dist};
	$Seen->{$dist} = join ', ', _metacpan()->release($dist)->{data}{license}->@*;
	}

=item * _main_module

Return the name of the main module

=cut

sub _main_module () { _settings()->{NAME} }

sub _make ( @targets ) {
	`$^X Makefile.PL 2>&1`;
	`make @targets`;
	}

=item * _metacpan

Get a L<MetaCPAN::Client> object

=cut

=begin ignore

{
"reporter":"\"Slaven Rezi&#x107;\" <srezic@cpan.org>",
"grade":"pass",
"osname":"linux",
"perl":"5.30.2",
"osvers":"5.4.0-33-generic",
"date":"2021-02-26T16:21:00Z",
"version":"2.127_04",
"guid":"a9a736ec-784e-11eb-841d-be631f24ea8f",
"dist":"Module-Release",
"platform":"x86_64-linux"
}

=end ignore

=cut

sub _metacpan () {
	state $rc = require MetaCPAN::Client;
	state $mcpan = MetaCPAN::Client->new;
	$mcpan;
	}

=item * _metacpan_page

Return the MetaCPAN page for this module

=cut

sub _metacpan_page () {
	"https://metacpan.org/pod/" . _settings()->{NAME}
	}

sub _module_to_dist ( $module ) {
	state $mcpan = _metacpan();
	state $cache = {};
	return $cache->{$module} if exists $cache->{$module};
	$cache->{$module} = eval { $mcpan->module( $module )->{data}{distribution} };
	}

=item * _open_darwin

Open a URL in Safari

=cut

sub _open_darwin ( $url ) { system 'open', '-a', 'Safari', $url }

=item * _releases

=cut

sub _releases {
	open my $fh, '<:utf8', 'Changes' or die "Could not open Changes!: $!\n";

	my @releases;
	while( <$fh> ) {
		state $count = 0;
		next unless m/\A\d/;
		trim($_);
		push @releases, [ split ];
		}

	\@releases;
	}

=item * _remote_exists( REMOTE )

Returns true if there's a remote with name REMOTE

	_remote_exists( 'origin' );

=cut

sub _remote_exists ( $remote ) {
	chomp( my @remotes = split /\R/, _capture_command( "git remote" ) );
	scalar grep { $_ eq $remote } @remotes;
	}

=item * _repo_exists( URL )

Returns true if the git URL is actually a repo.

	_repo_exists( 'git@github.com:briandfoy/ghojo.git' );

=cut

sub _repo_exists ( $url ) {
	my $output = _capture_command( "git ls-remote $url 2>&1" );
	$output =~ m/\A[a-h0-9]{40}\s+HEAD\R/;
	}

=item * _run_command( LIST )

Run LIST as a C<system> command.

=cut

sub _run_command ( @command ) {
	system { $command[0] } @command;
	}

=item * _run_git_command( LIST )

Run LIST as a C<system> command. If there is no F<.git> directory,
this dies.

=cut

sub _run_git_command ( @command ) {
	die "This is not a git repo!\n" unless -e '.git';
	unshift @command, 'git' unless $command[0] eq 'git';
	_run_command( @command );
	}

=item * _settings

Get the C<WriteMakefileArgs> from F<Makefile.PL>.

=cut

sub _settings {
	state $package = eval { require "./Makefile.PL" };
	die "Could not load Makefile.PL: $@\n" unless $package;
	die "Makefile.PL doesn't seem to have retuned a package name!\n"
		if $package =~ m/\A[A-Z][A-Z0-9_]+(?:\:\:[A-Z][A-Z0-9_]+)*\z/;
	state $settings = $package->arguments;
	$settings;
	}

=item * _ua

Returns a Mojo::UserAgent object.

=cut

sub _ua {
	state $rc = require Mojo::UserAgent;
	state $ua = Mojo::UserAgent->new;
	$ua
	}

=back

=cut

=head1 COPYRIGHT

Copyright © 2019-2022 brian d foy. All rights reserved.

=head1 LICENSE

You can use this code under the terms of the Artistic Licence 2.0.

=cut

__END__
my %WriteMakefile = (
	'MIN_PERL_VERSION' => '5.008',

	'NAME'          => $module,
	'ABSTRACT_FROM' => $main_file,
	'VERSION_FROM'  => $main_file,
	'AUTHOR'        => 'brian d foy <bdfoy@cpan.org>',
	'LICENSE'       => 'artistic_2',

	'CONFIGURE_REQUIRES' => {
		'ExtUtils::MakeMaker'   => '6.64',
		'File::Spec::Functions' => '0',
		},

	'BUILD_REQUIRES' => {
		},

	'TEST_REQUIRES' => {
		'Test::Data' => '0',
		'Test::More' => '1',
		},

	'PREREQ_PM'     => {
		},

	'PL_FILES'      => {
		'preprocess/Object/Iterate.pm.PL' => 'blib/lib/Object/Iterate.pm',
		},

	'META_MERGE' => {
		'meta-spec' => { version => 2 },
		resources => {
			repository => {
				type => 'git',
				url  => "$github.git",
				web  => $github,
				},
			bugtracker => {
				web    => "$github/issues",
				},
			homepage => $github,
			},
		},

	clean => { FILES => "$dist-*" },
	);
